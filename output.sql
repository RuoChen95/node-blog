SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;BEGIN;INSERT INTO `blog` (title, content, create_date) VALUES ('The Basic of Font-end Web Development', '\n\n本文是维基百科相关页面的翻译，主要介绍了前端编程的三大工具以及发展目的。\n\n前端网络编程，也被认为是用户端编程，是为了网页或者网页应用，而编写HTML，CSS以及JS代码，所以用户能够看到并且和这些页面进行交流。前端网络编程的挑战在于用于实现前端页面的工具以及技术变化得很快，所以工程师需要不断注意产业是如何发展的（例如去年的ECMAScript 6）。\n\n设计网页的目的在于：确保用户打开站点的时候，信息是以容易阅读并且相互关联的形式呈现的。随之带来的问题是，现在用户实用大量的设备来访问网页，这些设备具有不同的屏幕尺寸以及清晰度。所以设计者在设计网页的时候需要注意这些方面。他们需要确保他们的网页在不同的浏览器、不同的操作系统以及不同的设备上显示正确，这需要在工程师端进行仔细的计划。\n\n## 前端网络编程所使用的工具\n\n这里有一些工具能被用于进行前端编程，理解工具最适用于哪些任务，这有助于产生一个高质量的、可升级的站点。\n\n#### 超文本标记语言（HTML）：\n\nHTML是任何网页工程程序的骨架，没有它网页不会存在。超文本标记语言能提供站点总体的样子。HTML被Tim Berners-Lee所发展。随着HTML的发展，在万维网中产生了许多版本。最新版本的超文本标记语言被称为HTML5，在2014年0月28日被W3所推出。这一版本包含了新的并且高效的方式来传输元素，例如音频以及视频文件。H5在前端工程师中非常受欢迎。和老的版本相比，HTML5有很多特点。\n\n随着HTML的发展，在网络中产生了一场革命。现在，世界开始通过同一种语言相互交流，那就是超文本标记语言。其由两种部分组成，第一是**超文本**（就是超链接），第二是**标记语言**。\n\n#### 层叠样式列表（CSS）：\n\nCSS控制了站点的样子，让你的站点有自己独有的外观。其实现形式是：保证样式列表先于其他的样式规则，由其他的输入形式所影响，例如屏幕的尺寸和分辨率。\n\n#### JS：\n\nJS是基于场景的命令式语言（和HTML的说明性语言不同），用于将静态的HTML界面动态化。JS的代码能使用HTML标准提供的**文档对象模型**（DOM），来根据事件，例如用户的输入，操纵网络页面。\n\n使用一种被称为**异步JavaScript和XML**的技术（AJAX），JS代码也能动态的改变网页的内容（与原始的HTML页面端相独立），并且也能回应服务端的事件，让网页体验增加了真正动态的特性。\n\n## 发展的目的\n\n前端工程师牢记以下要点，使用可获得的工具以及技术来到达后端。\n\n#### 可达性：\n随着移动设备（例如例如手机和平板）的持续发展，设计者需要确保他们的站点在所有的设备中的浏览器正确运行。这能通过在CSS的样式列表中使用响应式的网页设计', '2016-11-12'),('The Picture of DorianGray', '\n\n这几天翻完了19世纪爱尔兰唯美主义作家王尔德的著名小说《道连·格雷的画像》，见证了一个俊美的青年是如何被一些话语教唆成为罪恶之人。小说中传达出来的一些东西需要自己警醒。\n\n1.生活需要真实\n\n不真实的生活是道连最后悲剧的原因之一，在其人生后期，其掩盖自己的身份在贫民窟逗留，吸食鸦片欺骗他人，甚至杀害了自己的朋友，但还觉得这只不过是自己人生的小小污点。这种不真实到最后还是被他人所察觉或是怀疑。在小说的最后，两位绅士对于道连的生死的反应是：“冷笑一声走掉了”。很明显在道连所处的阶级中，其风评是很差的。\n\n2.需要珍惜时间\n\n20岁出头的时间是最为宝贵的。道连·格雷的人生最有戏剧性质的就是其容颜一直保留在20多岁，但是其灵魂是越来越不洁的，而这种道德上的变坏表现在了他早年肖像画上。直至他40岁决定破坏那幅画而导致自己死亡的时候，他内心的污秽才在他的肉体显现了出来。无论如何，20多岁是一个人精力和颜值的巅峰，作者正是以道连·格雷“永恒的”20岁的美好外貌来和内心的不断堕落来做对比，强化了文章的戏剧性，为最后的悲剧结局做好了铺垫。\n\n3.生活是感性的\n\n生活是个神经的问题，纤维的问题，是逐渐进化而成的细胞的问题，其中埋藏了思想，激情在其中有着它的梦。我们生活所依靠的不过是屋子里或早上的天空里一抹随意的颜色；曾经爱过的一种带着你细腻的回忆的特别香味；偶然遇见的已经忘却的诗行；或是已经不再弹奏的乐曲中的一段旋律。', '2016-9-26'),('一个公司需要什么样的人才', '\n\n无论是大学本科，研究生还是出国，上学最终的目的是去某家公司工作。所以，在上学的时候明确公司需要什么样的人才是十分重要的，而这一要求，在各大招聘网站中的招聘要求中有明确写出，现加以分析整理如下：\n\n## 团队合作能力\n\n公司是一个团队，代表了一群人一起完成某样任务。作为团队的领导，要明确各个队员的分工；作为队员，要保证完成自己的任务，这样公司才能持续创造价值。所以公司对于经理的要求是要有创造力、活力来分配好工作并且保证工作完成，对于员工的要求是有团队协作能力。\n\n为了保证团队合作能顺利进行，在集体中的每个人都要学会一件事，那就是多说。语言让人在大尺度上学会了合作。交流就像润滑剂，不但能减少误会的产生，还能提高合作的效率。交流可以在合作时交流，也可以在合作后（生活）交流。\n\n为了保证团队合作能有成果，每个人的必须是以结果为导向的(result directing)。如果一个团队大家都很忙，但是没有结果，那只是瞎忙。优良的成果的一个很重要的一点就是能被社会理解。这要求这个成果可以被复制。例如在科学研究中，很强调实验成果的可复制性，这样这个成果才是不虚假的，可以依赖的(reliable)，可以形成结论。\n\n## 个人的有序\n\n当一个个体加入了某一团体之后，为了完成上级分配下的任务，公司会要求其需要有计划(well-organize)，高效的完成。一个人如果做事无序，三心二意，最后往往难以完成任务或者任务的完成度很低。对于大学生，就像在去自习的时候玩手机，最后导致整个晚上都被浪费了。\n\n一个目标的实现，是需要一步一步来的，不可能一口吃成个胖子。所以，大的目标是需要分为多个小目标的。此外，明确目标完成的具体指标也十分重要。例如仅仅说要去锻炼是不够的，而需要有具体的计划，例如上午慢跑30分钟，晚上练习平板支撑5分钟。因此，对于目标的分解(division)以及特化(specification)是有序的前提。\n\n除此之外，有序还需要做到连续。连续可以分为两个角度：工作的连续以及关系的连续。工作的连续需要人不断产出(hard working)，当老板发现你在玩手机心中肯定会大大失望的。这也是为什么考试是连续的，除非时间特别长的考试，例如4小时以上的，才会有很短的时间（10分钟）来让你休息。能保持长之间的专注的人才是一个公司所需要的。此外，由于公司的运作是持续不断的，所以人与人的关系是有连续性。这种关系并不会随着某一任务的结束而终止。\n\n总的来说，公司最关心的事有两件，一件是你能不能做好这件事，另外一件是你能不能和他人一起做好这件事。这两个点完全可以在求职之前加以锻炼，以提高自己的竞争力。\n', '2017-4-19'),('我是如何构建博客的', '\n本文主要的目的是梳理如何我在使用github.io、jekyll以及jekyll-now搭建博客所踩过的坑、心得以及遗留下来的问题。目标读者是想自己搭建博客的人。\n\n文章会一点点更新。\n\n首先，github.io是简单的博客服务器，只要你有github的账号，就能搭建自己的博客，github.io所搭配的框架就是jekyll。\n\n安装jekyll需要ruby以及ruby Gems：\n1. ruby的版本需要大于2.2.5，小于2.5，windows具体安装地址是[这里](https://rubyinstaller.org/downloads/)；mac的具体安装可以通过gem包管理器\n2. ruby --version无效的话需要换个目录文件夹安装\n3. 在安装的时候只用勾选PATH那项，不用安装msy32\n\n安装完后运行jekyll serve如果报错：<code>jekyll 3.8.5 | Error:  No such file or directory</code>，需要检查当前目录是否正确。\n\n', '2017-4-8'),('Liferay实践回顾', '\n\nliferay是一个开源Java库，通常是作为企业的内网系统。这个库将页面的不同元素，例如日历、开会计划等作为模版，用户可以通过模版来组织页面格式。由于公司项目要求，已经学习、使用了一段时间。以下是主要的学习进程，很多东西没有用到，但是需要记录。\n\n## 通过配置文件开发\n\n### 加载自定义CSS\n\n通过管理员账号登陆后，在导航-页面-配置-外观和风格-CSS中直接导入想要改变的CSS代码即可。主要通过className来区分页面。注意页面的配置中的外观和风格处选择“使用和私有页面相同的外观”，而不要选“为此页面定义一个独有的外观”。\n\n### 载入HTML\n\nlifery 的wiki portel中的一项支持HTML代码，并且为表格文档提供编辑器，能让用户自己编辑表格。表格的格式可以通过CSS改变。这个portel还有一个特点，就是可以支持单页面以及js行为控制，这就配合css的<code>display:hidden</code>等属性，能够实现页面的定制化。\n\n### 执行JavaScript\n\n如果需要动态改变CSS，需要导入JavaScript，这个时候可以在导航-页面-配置-高级的-JavaScript中加上你需要的代码，这会被全局应用。框架已经自带jQuery，但是没有Boostrap。\n\n### lar包\n\n上述内容都配置完之后，可以在系统的导出界面导出lar包，然后可以在默认界面中将lar包进行导入，应用样式、结构以及portel。lar包可以通过[相关](http://blog.csdn.net/caroline_wendy/article/details/42190743)命令行进行解压以及压缩。<a title="17.5.31">目前</a>的问题是导入导出后会报出<code>java.lang.NullPointerException</code>的问题。\n\n## 通过命令行开发\n\n### 环境\n\n需要三大类环境：node，npm；yeoman；SASS from Ruby。根据[教程](https://dev.liferay.com/zh/develop/tutorials/-/knowledge_base/7-0/themes-generator)配置即可。但是，npmrc文件如果按照上面要求修改，环境会报错安装不上，npm在后续构建theme的时候也会报错。\n\n### portal_normal.ftl\n\n../\"theme name\"/src/templates/portal_normal.ftl文件是liferay模版文件，改了其中的代码后可以直接在主页中显示出来，是主要需要进行修改的地方。具体可以直接调用的模版是宏（[macros](https://dev.liferay.com/zh/develop/tutorials/-/knowledge_base/7-0/freemarker-macros)）,其中的date宏不能直接调用，control_menu如果已经有了调用后会和已有的重叠，breadcrumbs只能调用一次，user_personal_bar就是一个简单的小用户界面。\n\n调用后在theme文件中使用<code>gulp deploy</code>就能生成build文件，然后在对应的tomcat文件夹中用.sh文件部署服务器即可实现这份ftl文件的改动，注意需要在feel and look中选择相应的样式。样式方面，可以通过改变_custom.scss实现。\n\n目前的问题，无法自定义宏以及不知道连接前后端。\n\n### Liferay Theme Generator\n\n激活代码是<code>yo liferay-theme</code>\n\n使用yeoman引入这个主题构建器，这个构建器会创建好一个主题的架构。在文件中会有一个src文件夹，这个src文件夹会存储进行改动的文件。其中的CSS文件是以Sassy CSS文件存储的。这个构建器还能通过<code>yo liferay-theme:layout</code>以及<code>yo liferay-theme:themelet</code>来改变页面的基础布局以及增加小组件。目前的问题如果使用这个方式，将theme构建好之后不知道如何应用到已经在tomcat上跑起来的页面中……\n\n## 通过Eclipse开发\n\n### Liferay IDE\n\n这是一个liferay的eclipse插件，可以通过eclipse插件广场上搜索下载。安装这个插件之后，在加上Java 8，就能新建基于liferay的项目了。\n\n### liferay SDK\n\n这是一个liferay的工具包，在新建项目的同时，需要将这个工具包所对应的文件位置引用一下。目前有个问题，就是文件引用的时候会报出“Invalid SDK settings. Configure app.server.parent.dir property in build.admin.properties to point to Liferay home”错误，解决方式就是找到build.properties文件，讲文件名称改成build.<你的电脑名字>.properties,然后在其中的app.server.parent.dir的值改成liferay portal的绝对路径。\n\n### liferay portal\n\n这是liferay所构建的JAVA页面，其中包括用于渲染页面的tomcat文件。它能体现liferay的基本的功能，但是没办法改样式。\n\n### liferay portal SRC\n\n这是liferay的工程源码，可以通过软件导入，不能用eclipse，文件格式也不是mavern。由于整个门户过于复杂，源码分析不现实，如果需要改样式的话需要通过新建模版完成。', '2017-5-8'),('OKR页面构造实践以及工作回顾', '\n想要做的事情\n- 建立对自己的信任\n- make something original and worthwhile\n- 发现美好的东西，使用并感受其美好\n- 创造美好的东西，有利于个人以及集体进步的东西\n\n不应该做的事情\n- 晚睡晚起\n- 迟到\n- 不吃早饭\n- 编写自己都看不懂的代码\n- 在公司的工作时间做与工作以及学习无关的事情，例如浏览购物网站或者在游戏里抢红包\n- 代码重复使用的时候不进行封装\n- 不使用className而进行遍历搜索\n- 表达不圆润，推卸责任\n- 有意识的明确表达函数内作用域\n- 对于任务的完成时间没有精确的估计\n- 测试的时候没有回归到初始化状态\n\n应该继续保持的事情\n- 在做的时候自己探索、明确页面逻辑\n- 先完成正确、关键、最简化的代码，然后对这代码进行复用以及扩展，考虑一些特殊情况\n- 使用each()等非for迭代函数(函数化编程)\n- 做一些需求之外的必要的功能\n\n需要做的事情\n- 有一定的艺术感，对比性，进行对比度的测试\n- 多吃东西，锻炼身体\n', '2017-7-13'),('vue技术实践回顾', '\n本文的主要目的是梳理过去三个月的时间在公司使用vue的经过，碰到的相关信息，以及需要改进的问题。目标读者是对vue以及前端有兴趣的人。\n\n本文会一直更新，直到商城全部重构完成。\n\nVue.js是一个开源Javascript框架，用于构建用户界面，由于是数据驱动的，不用查找DOM元素，所以这个框架能够简化代码，加快开发速度。Vue还有官方library，包括用于控制路由的vue-routing，也有用于状态管理的vuex。Vue的主要功能比较简单，容易入手，功能相对来说比较全面，所以我们决定使用vue。\n\n## vue下的登录\n\n用户登录比较复杂，目前了解到，其涉及到4处服务器：\n\n1. 本机（用户）\n2. 登录服务器（接口提供方）\n3. cas服务器（公用）\n4. redis服务器（公用）\n\n登录的具体步骤为：\n\n1. PC打开网页，向登录服务器发送请求，由于没有ticket，登录服务器返回401；\n2. PC重定向到cas服务器，进行登录，登录成功后cas服务器生成ticket传给PC端，并且生成对应的ticket表（包括用户信息以及对应的），并将ticket表上传到redis服务器中。\n3. PC获取ticket后再向登录服务器发送请求，登录服务器获取ticket后到redis服务器中进行核对，核对通过，登录成功。\n\n补充：第二部成功后，cas服务器会生成JSESSIONID，种植到浏览器的cookie中；登录服务器通过校验用户名 + JSESSIONID + ticket来判断用户是否登录了。\n\n## vue的组件封装\n\nvue的生态繁荣，框架比较多，在UI工具上，我们用了elementUI以及iviewUI。这些UI工具其实就是一些封装好的组件，用法官网上写得很明确了。\n\n样式自定义：需要去App.vue文件中进行全局修改，不能在不同的组件文件中进行修改，否则会由于vue的组件绑定机制导致修改失效。[iview](https://www.iviewui.com/docs/guide/theme)上说的变量覆盖方法并非最简。\n\n组件功能复用：使用[混合](https://cn.vuejs.org/v2/guide/mixins.html#%E5%9F%BA%E7%A1%80)，此部分待续...\n\n普通组件以及实例化组件：框架自带的实例化组件只能同时使用一个，所以有的时候需要两者共同使用。\n\n父子组件通信：上行使用“:”，下行使用“@”，具体用法可见官网。父子组件通信也可以用vuex，但是vuex + 异步传输存在问题。\n\n## 接口对接\n\n进行重构的很重要一点就是要注意之前的接口是如何写的，这样才能全面了解项目的需求以及代码量。除此之外，开始mock接口前需要花一些时间来核对接口的合理性，接口确定后尽量不要修改，这样就能加快开发速度。\n\n在对接时，要和后端沟通好，接口之后必然有修改，要预留足够的修改时间。\n\n## 功能封装\n\n详见下一篇文章。', '2018-1-1'),('博客改版计划', '\n\n当前我的博客是直接用了https://github.com/barryclark/jekyll-now的项目代码，可以说它的"developer experience"非常的好。\n\n1) 具体文章可以在_posts文件夹内进行更新\n\n2) 项目文件打包后直接放到projects中，然后在_layouts文件夹中的experience.html配置路径。router是根据文件路径自动生成的。例如todoApp的index.html的路径为projects/todoApp，则路径为<code>{{ site.baseurl }}/projects/todoApp</code>\n\n### 新版博客计划\n\n1. 用vue\n\n2. 部署\n\n这么做的原因是为了增加对于博客的控制，以便之后增加评论以及统计功能。\n\n还有一点就是"Creating the resource plugin"。\n\nP.S. 目前计划搁置中', '2018-12-14'),('Git rebase', '\n\n今天下午，花了小半天的时间看了下git文档的分支部分，目的是学习一下git rebase，\n分支的操作其实有以下三种：\n\n\n### 本地分支合并\n\n监控当前文件：git add 文件名 (每次文件修改都要add一下，不然不会监控上)\n\n查看分支：git log --oneline --decorate --graph --all\n\n如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged\n\n遗留问题：git branch -d test 删除test分支 其实还可以通过git checkout test回归，这是为啥？（如果出现：error: The branch \'testing\' is not fully merged.，正如字面意思一样，需要合并下）（顺便：远程分支通过 git push origin --delete test 删除，这个时候不能通过checkout回归，这个时候如果要[恢复](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF#_%E6%8B%89%E5%8F%96)怎么办）\n\n\n### 远程分支合并\n\ngit merge origin/master\n\n然后会出现报错，需要[处理冲突](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6#r_basic_merge_conflicts)。\n\ngit add + "冲突文件的relative path"\n\ngit commit + 回车：这个时候会出来vi文本编辑器，编辑完成后，push即可。\n\n### 变基\n\n#### 人员A的行为(想将子分支合并到master上)\n\n1. 去子分支；git rebase master\n\n2. 处理冲突；\n\n3. (指针哈希值，奇怪) git add README.md\n\n4. (指针哈希值，奇怪) git rebase --continue\n\n5. git会自动跳回到了experiment分支，变基完成\n\n#### 人员B的行为（之前在master分支上开发）\n\n理想情况下直接git fetch之后merge。除此之外，需要一些特殊的[解决方法](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#r_rebase_rebase)。"总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作"。\n\n\n\n\n\n\n', '2018-12-19'),('工作回顾以及未来打算', '\n\n最近公司的首页第二次改版基本弄完了，昨天也把一些编写得比较随意的代码进行了优化，又来到了比较"闲"的时候，是时候进行一些计划了。之前"闲"的时候去看了一些[服务端部署](https://github.com/RuoChen95/imooc-nuxt-study-project)以及[express](https://github.com/RuoChen95/imooc-express-movie-project)的知识，但是只涉及皮毛，而且没有一定的计划和目标，浪费了一些时间。\n\n之前在简书上有一些回顾，分别在去年[8月](https://www.jianshu.com/p/bfd2798924f8)，[10月](https://www.jianshu.com/p/1e9358f4a3db)以及今年[3月](https://www.jianshu.com/p/5ffe75782434)。\n\n> 如果没有执行力以及规划力，迟早会被淘汰，这在任何行业都是如此。\n\n### 时间\n\n目前工作日会8:15~9:45起床，然后9:15~10:00到公司。然后看一下jira，根据上面分配给自己的bug/task进行工作；或者回忆一下给自己分配的任务，给自己建task后开始工作。中午依旧会11:30去吃饭，然后12:45回来，中午会看书/玩游戏，到1:30后睡半小时然后在2:00开始进入工作状态。完了后有一段时间和同事一起在6:00～6:10下班，现在去楼下吃饭。照理说早下班的话应该9:00到公司，才能有8小时工作时间。目前基本不存在加班的情况，每周四有上线，需要进行值班，但是通常也在晚上8:00完事。由于部门人多，部门上已经好久没有聚餐了。\n\n关于下班进行学习的策略，目前比较喜欢的方法是去星巴克学习，还能增加认识人的机会。这么做差不多能满足下班后七点到九点2小时的学习时间。周末的话可以去一下午，到三个小时左右。\n\n### 内容\n\n很难对学习内容进行确定。在上几篇回顾中，我有一些计划，但是其比较模糊，完成情况也并不理想。毕竟，"自我学习"，不但缺少提纲，还缺少测验，最终导致了自己缺少对于进度的把控以及中途的放弃。\n\n#### 学习服务器端网页编程\n\n目前的，以及之前比较闲的时候的好长一段时间，可以说自己将目标模糊的确立为[服务器端网页编程](https://developer.mozilla.org/zh-CN/docs/Learn/Server-side)。从"前端"转向"后端"是一个十分自然的行为。这对于知识才有完整的把握，而且也是官方(MDN)所[推荐](https://developer.mozilla.org/zh-CN/docs/Learn/Server-side)的："在现代的网页开发世界里，学习服务器端开发是高度推荐的"。\n\n关于服务器端网页编程的具体技术，已经进行了很长一段时间的"瞎学"。需要进一步花时间分析，初步计划是先去Wiki上看看，或者[如徐宥所说](https://blog.youxu.info/2012/02/02/software-tools-1/)去找一本非常简单的书熟悉领域模型，获得一个 Big picture，而非上来就想着要解决手头的问题。\n\n#### 学习JS\n\n工作中学到了很多，Vue.js，异步，原型链。甚至有的时候并不理解这个知识，但是已经用得很多了。接下来，需要看[一些书](https://book.douban.com/subject/26351021/)，总结一些解决方案。\n\n#### 学习Git\n\n目前不懂[git rebase](../Git-rebase/)。其他的中级知识，例如git revert也得找个时间总结下。\n\n#### 深化\n\n最近[有一篇文章](https://www.forbes.com/sites/rajatbhageria/2017/09/10/is-learning-how-to-code-still-worth-it/#5cb5bb0b75a1)提到，学习"web-app"是缺少竞争力的。[具体解决方案](https://www.jianshu.com/p/28885fd80348)除了除了学习ML，blockchain等替代性低的知识；也需要了解编程之外的例如经济以及新闻知识。\n\n\n\n\n\n', '2018-12-19'),('服务端编程基础(Node)', '\n\n二年又一个月之前，我从这篇[翻译](https://www.jianshu.com/p/85b93bd0779d)开始，进入了网页开发领域。当初我写下这篇翻译开始，万万没有想到我当初一时的兴趣会引导我进入[现在的生活](/blogDetail?title=工作回顾以及未来打算/)。\n\n这两年的前半部分时间，由于"生存以及未来"的压力，在比较恶劣的条件下进行学习。后来自己住后，由于生活稳定，反而越来越远离于自我提高了。对于知识，简单的满足于***了解***，而没有进行***吸收***。在不了解的领域，依旧是属于[无知的状态，也没有耗费心力将无知转为有知](https://blog.youxu.info/2010/02/03/informed-ignoranc/)。\n\n对于知识的正确态度是[强调工程实践](https://segmentfault.com/q/1010000001589389#a-1020000001637923)，而社会上的工程实践其实就是工作。那么目前主流的工作要求是什么就具有一定的指导价值了。目前[京东](https://www.lagou.com/jobs/5279599.html)的全栈要求如下：\n\n1) 统招全日制本科及以上学历，8年以上工作经验\n\n2) 掌握JavaScript基本原理，熟悉ES5/ES6特性，理解函数式与面向对象特点；\n\n3) 熟悉Web性能优化、浏览器基本原理、网络安全等相关知识；\n\n4) 熟悉常见Web框架，对实现原理有深入认识，熟练使用主流前端框架至少一种；\n\n5) 了解前端自动化、熟悉webpack、gulp等工具，有浏览器兼容问题处理和性能优化经验可优先考虑。\n\n加分项：\n\n- 具有React Native, Electron开发经验优先；\n\n- node.js（Koa，express）项目开发经验，精通数据库技术，mySQL, redis或Mongo DB.\n\n- 熟悉[WebSocket](http://www.ruanyifeng.com/blog/2017/05/websocket.html)，Mqtt，xmpp 加分\n\n目前思路就是很清晰了，学习node、Redis、mySQL、[WebSocket](http://www.ruanyifeng.com/blog/2017/05/websocket.html)（目前我心目中的服务端编程基础的"big picture"）。\n\n', '2018-12-20'),('网络编程基础', '\n\n在[上一篇文章](/blogDetail?title=服务端编程基础(Node))中，提到了一句话：Node.js将简单的脚本语言（JS）和***Unix网络编程***结合在了一起[[1](https://books.google.com.hk/books?id=ZH6bpbcrlvYC&printsec=frontcover&dq=nodejs&hl=en&sa=X&redir_esc=y#v=onepage&q=nodejs&f=false)]。那什么是Unix网络编程？什么是Unix编程？什么是Unix？\n\n以下内容源自维基百科[Unix页面](https://en.wikipedia.org/wiki/Unix)的翻译：\n\nUnix是一系列多任务、多用户的计算机操作系统，源自于AT&T Unix，其在19世纪80年代在贝尔实验室被Ken Thompson、Dennis Ritchie等人开发完成。\n\nUnix系统以模块化设计为特点，有的时候被称作Unix哲学。这个概念包括操作系统需要提供一系列简单的工具，每一个工具提供了一个受限的，定义清晰的功能，将统一化的文件系统、shell脚本以及命令语言（Unix脚本）作为主要交流手段。Unix将其作为第一款便携式操作系统，以和其先辈进行区分。几乎整个操作系统是以C语言所编写的，所以让Unix能有宽广的平台。\n\n所以Unix就是一系列操作系统，Unix编程就是面向这些操作系统写应用，Unix网络编程就是面向这些操作系统写网络应用。\n\n', '2018-12-24'),('Array.map，forEach，filter以及reduce', '\n\n目前在学习函数式编程，以前浏览过但是一直没用，这次打算尽可能用到这一思想。\n\n### Array.map\n\n其相当于强制遍历这个Array，如下代码：\n```\n    var array1 = [1, 4, 9, 16];\n    \n    const map1 = array1.map(function(x) {\n    	if (x > 1) {\n        	return x\n        }\n    });\n    \n    console.log(map1);\n```\n这个代码会返回```[undefined, 4, 9, 16]```。\n\n### Array.forEach\n\n其为map的弱化版，并不会返回一个新的array，如下代码：\n```\n    var array1 = [1, 4, 9, 16];\n    var map1 = []\n    const map2 = array1.forEach(function(x) {\n    	if (x > 1) {\n        	map1.push(x)\n        }\n    });\n    \n    console.log(map1, map2);\n```\n这个代码会返回```[4, 9, 16],undefined```。\nforEach的速度通常要比map[慢](https://codeburst.io/javascript-map-vs-foreach-f38111822c0f)。\n\n### Array.filter\n\n其对于map进行了优化，如下代码：\n```\n    var array1 = [1, 4, 9, 16];\n    \n    const map1 = array1.filter(function(x) {\n    	if (x > 1) {\n        	return x\n        }\n    });\n    \n    console.log(map1);\n```\n这个代码会返回```[4, 9, 16]```。\n\n比较常用的做法是链式调用```const map1 = array1.filter(FUNCTION).map(FUNCTION)```。\n\n补充：slice和filter的区别：小数据一样快：https://jsperf.com/ruochen-slice-vs-filter；大数据slice快：https://jsperf.com/slice-vs-filter\n``\n### Array.reduce\n\n我对于reduce理解是其通常用于"降低数据复杂度"。[如下代码](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Grouping_objects_by_a_property)，函数体内return的数据会赋值到下一次循环中的acc中。\n\n值得一提的是，这些方法和ARRAY.slice()类似，并不会影响到原有数组（在这个例子上为array1）', '2018-12-4'),('npm package技术实践', '\n\n基本目的：将vue组件上传到npm文件服务器上，方便不同项目的调用，做到组件的解耦以及脱水。目前计划尝试解耦新做的coupon组件，后续计划解耦页面头尾，步进器。\n\n需要进一步学习：\n\nvue方面：\n\n* 父子组件事件传递（已完成）\n* 插槽slot（已完成）\n\nnpm方面：\n\n* 上传npm package及其使用（已完成）\n* webpack的构建步骤/将vue文件编译成js文件/build a vue component library\n\n', '2018-7-15'),('前端频控实践', '\n\n需求背景：用户快速点击步进器的时候，每次增减都通过了前端校验，需要传至后端进行校验，需要控制传参的频率，降低服务器压力。\n\n参考：\n\n* https://cn.vuejs.org/v2/guide/computed.html中的debounce\n* https://lodash.com/docs#debounce\n\n在线demo：\n\n* https://codepen.io/a7304795/pen/ZvLQyz\n\n基本思路：\n\n使用lodash的debounce参数实现频率控制。由于需要进行异步请求，经过尝试发现，将方法放在data内部，而非method内部能够实现方法的正确调用。具体代码如下：\n\n```\n// install loadash\nimport _ from \'lodash\'\n\nexport default {\n    data () {\n        ajax: _.debounce(async function (subProduct, index) {\n            let data = await this.change(subProduct.shopcartId, subProduct.productCount)\n            if (data.code == "0") {\n                // 通过后的行为\n            }\n        }, 300)\n    },\n    //...\n    methods: {\n        decrease (index) {\n            if (前端校验) {\n               this.ajax(subProduct, index) \n            }\n        }\n    }\n}\n```\n\n\n\n细节问题：\n\n* debounce的原生JS实现：使用setTimeout()方法设置一个定时器。\n* debounce和throttle的区别：在demo中将debounce换成throttle可以很明显的看到区别，throttle中设置的间断时间并不会等待用户停止（空闲）后再进行赋值。这会导致请求两遍。\n\n遗留问题：\n\n* 为何要在data中设置函数，在method中设置为何回导致异步 + debounce 函数无法调用', '2018-7-30'),('关于MVVM模型的反思', '\n\n本文只针对前端框架。\n\n简单的来说，MVVM模型由下述三个部分组成：\n\nView: HTML, 渲染数据\n\nModel: JS, 定义数据，从接口获取数据，操作数据，业务逻辑层\n\nViewModel: 底层JS，用于同步View和Model，以及维护数据，本质还是操作DOM元素。\n\n1. 视图层 - Compiler层：即"指令编译器"，对每个元素节点的指令进行扫描和解析。例如@click="functionX()"，就是addEventListener(\'click\', functionX() {...})\n2. 数据层 - Observer层：和Angular.js的脏数据检查不通，Vue.js使用的是数据劫持方式，对于data进行遍历并重写它们的setter和getter方法，从而实现监控数据的调用(get)和数据的设定(set)。\n3. VM层 - Watcher层：\n    1. 监控数据，更新视图；\n    2. 监控指令，修改数据，更新视图；\n    \n还是不怎么理解。\n\n', '2018-8-11'),('eslint + prettier + lint-staged代码校验配置方式回顾', '\n\n基本目的：代码的风格需要统一，统一的代码风格也能降低项目出错的概率，例如能够校验v-for后是否加了:key，防止列表渲染出错。同时，为了提高效率，可以使用prettier自动将代码风格统一。\n\n相关链接：\n\n* [prettier官网](https://prettier.io/)\n* [eslint官网](http://eslint.cn/docs/user-guide/configuring)\n\n基本思路：\n\n### 增加的package文件：\n\n* prettier\n* eslint-config-prettier: Turns off all rules that are unnecessary or might conflict with Prettier.\n* eslint-plugin-prettier: \nRuns Prettier as an ESLint rule and reports differences as individual ESLint issues.\n* eslint-plugin-vue: Official ESLint plugin for Vue.js\n* vue-eslint-parser: The ESLint custom parser for .vue files, dependencies of eslint-plugin-vue.\n* lint-staged: Before committing your code, fun lint;\n* husky: Prevent bad commit\n\n```\nnpm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier eslint-plugin-vue vue-eslint-parser lint-staged husky vue-loader@13.7.2\n```\n\n### 修改eslint配置文件：\n\n```\nmodule.exports = {\n  root: true,\n  parser: \'vue-eslint-parser\',\n  parserOptions: {\n    parser: \'babel-eslint\',\n    ecmaVersion: 2017,\n    sourceType: \'module\'\n  },\n  env: {\n    browser: true,\n  },\n  // https://github.com/standard/standard/blob/master/docs/RULES-en.md\n  extends: [\'prettier\', \'plugin:vue/essential\'],\n  // required to lint *.vue files\n\n  // using \'html\' plugin will alert: "warning  Delete `⏎`  prettier/prettier"\n  plugins: [\n    \'prettier\'\n  ],\n  // add your custom rules here\n  \'rules\': {\n    \'prettier/prettier\': [\'warn\'],\n  }\n}\n```\n\n### 增加npm命令：\n\n* 用prettier将文件统一：```"format": "prettier --write \'{src,config,mock}/**/*.{js,json,vue,less}\'"```\n* 用eslint校验代码格式：```"lint": "eslint --ext .js,.vue src"```，具体含义就是校验.js文件，.vue文件以及src目录下的文件。\n\n### 增加.prettierrc文件：\n```\n{\n  "printWidth": 120,\n  "semi": true,\n  "singleQuote": true,\n  "trailingComma": "es5"\n}\n```\n\n### 增加git hooks配置：\n```\n  "husky": {\n    "hooks": {\n      "pre-commit": "lint-staged"\n    }\n  },\n  "lint-staged": {\n    "*.{js,json,vue,less}": [\n      "prettier --write",\n      "git add"\n    ]\n  },\n```\n\n', '2018-8-2'),('购物车弹出框组件的构建回顾', '\n\n基本目的：梳理知识点，举一反三的基础。\n\n', '2018-8-9'),('步进器组件的构建回顾', '\n\n目前曳光弹页面已经上传到gitlab.bitmain.com上了，在h5项目上已经用这个组件很长一段时间，但是将其抽象到组件库后发现，还有一些可以提高的地方。\n\n1. 对于非数字的处理：首先设置input框的类型为number，并且将css覆盖input样式为textfield；当输入错误内容的时候，blur之后返回之前的数字，并且提示。\n\n2. 对于不符合规范的数字的处理：如果输入小于最小值，则在input的时候将value置为最小值，反之亦然。\n\n3. 数据传递：value为父组件入参；currentValue为当前组件参数；oldValue为上一次通过校验后的参数，在点击按钮以及blur的时候改变。', '2018-9-13'),('工作期回顾', '\n\n在[之前的文章](/blogDetail?title=工作回顾以及未来打算)中提到了我最近的回顾，侧重点在于每天的工作内容。其实，从入职到突然离职这整个快两年的工作周期内，我经历了如下的事情：\n\n1. 老项目维护（试探）：刚进公司的时候，老的官网项目使用JSP写的，主要由后端主导。前端的工作只是写HTML以及CSS就行，JS上只是一些小的页面控制，工作量比较小。痛点在于，这个项目过老导致了CSS文件的耦合性非常的紧密，难以维护。\n\n2. 在框架的基础上增加功能：后来分配到了一个组主要是在liferay这个成熟的项目框架上构建功能（OKR），由于页面的HTML以及CSS无法控制，只能通过JS注入的方式来实现功能的增加，所以用到了大量的JS（主要是jQuery框架），整个组就只有两个后端一个前端，前端部分全部由我来实现。痛点在于，使用了闭源的框架导致了无法修改源码，开发上的阻碍过大。\n\n3. 老项目重构：官网项目由于需求的不断累加导致了不得不进行重构。具体重构流程从"不怎么重要的"售后开始练手，然后修改购物流程，最后修改首页和产品详情页，完成了初次的重构。由于这段时间不但要新使用以前不会的单页面前端框架（Vue.js整个体系），还要兼顾老项目的维护，工作量最为巨大，但是成长也十分快速。痛点在于，这种短平快的项目在需求设计以及UI设计之初就没有实现正确的项目流程，为了求稳，所有的需求都是参照老项目的代码。代码层的确重构了，但是"需求层"没有重构，导致了这次重构其实并没有获得高层的满意。\n\n4. 重构的扩展：在测试以及开发的努力下，项目上线后并没有较大问题，于是将重构进行扩展。具体扩展内容为增加H5页，个人中心页以及售后支持页。其中需要指出的是，H5页面只用了一个月开发，涉及到了之前的所有流程，任务量巨大。到个人中心的时候，还需要边开发边维护老项目以及之前重构的项目，最后也勉勉强强的上线了。之后的售后支持页比较简单。这个时候，对于开发、测试到上线的整体流程都非常熟悉，只是机械化的工作罢了。痛点就是需要维护多个页面，分散了较多精力。\n\n5. 第二次重构：之前的前端重构完成后一段时间组里又开展了后端的一些优化工作，前端这个时候任务量下降没啥事情。后来产品经理开始推新的一轮重构，由于"种种原因"，售后项目没有推起来，于是开始推动首页项目。这次重构需求更为复杂，基本上是做成了一个可配置的页面。复杂的配置页任务并没有分配给我（那个时候我在进行一些维护工作），最后我主要负责产品详情页面的展示。项目的痛点在于任务并没有进行比较清晰的分配，导致了耗费了一些无用的工作量。\n\n6. 离职前夕：18年很长一段时间的币价在下跌，导致了公司一整年也没有赚到多少钱。再加上年中的大量招人导致了公司的用人成本急剧上升。最为致命的是公司体量大，涵盖了研发、物料采购、生产、售后的一套流程，每一个流程都会耗费大量的资金，以及存在难以追查的黑幕。最终导致了公司的裁员浪潮。由于前端属于"[资源池](https://www.zhihu.com/question/307381805/answer/565152434)"，在需求链中属于末置位，不可替代性弱，最终导致了自己的被裁员。\n\n总的来说，我在上家公司里经历了差不多有两次的项目循环周期，学到了很多东西。唯一的遗憾在于下班后的时间一直没有好好利用来提高自己，也没有懂得进一步扩展自己的圈子。这次被裁是一种提醒，也是一次机遇。希望下次也能进入这种福利好，管理扁平的公司。\n\n一个公司肯定会有大大小小的问题，作为个体如何明哲保身？主要需要能够获取信息资源，培养自己的能力资源。做任何职业都需要这两种资源，可能在不同阶段这两类资源的侧重点不同。我的理解是，信息资源需要有广阔的交友圈子，能够通过各种方式获取自己想要的信息。能力资源需要自己能够让人将事情分配给自己，并能将事情做好。前者需要时间以及阅历，后者需要通过持续的自我学习来加以提高。', '2019-1-5'),('博客搭建回顾', '\n现在网上的博客搭建教程偏向于普通用户，在别人的CMS下进行搭建，用起来限制挺大的，想加的一些功能不太好加，所以一直就想将之前的博客进行改版。断断续续花了三周的时间总算把博客搭建完了，包括初步的客户端、服务端构建以及两波迭代。具体整理如下：\n\n### 前端\n前端还是老套路，Vue.js全家桶 + axios处理接口，大部分逻辑放在前端。为了方便开发，目前接口全部是用await转成同步的。图表用了百度的echarts，导致了最后的打包文件有400多kb，会影响到页面第一次的加载速度，之后浏览器会读取缓存，就没有太大影响。组件有三个，评论、折线图、柱形图。评论接口通过groupArea进行评论区域的区分，目前还没有做回复以及多级回复功能。IP统计的逻辑用到了三个接口，获取IP、判断IP是否今日访问过以及入表接口，前端处理。目前博客数目较少，没有做分页处理。安全上也没有做XSS防护。\n\n\n\n### 后端\n用了个最简单的node服务器，router都没写，而且接口都是get的。后端目前就是个练习写sql的地方，逻辑比较简单，对于页面的性能没有什么比较大的影响。比较坑的地方是时间的处理，需要后端自己转成合适格式的字符串再传给前端，但是\'true\'或者\'1\'这种字符串会自动转成对应的布尔值或者数字。\n\n获取IP的接口需要在nginx上进行配置才能生效。统计接口需要在SQL种进行适当的处理。\n\n一开始我还想研究下如何显示接口的加载情况，后来发现主要就是sql语句，并没有提供一个方法来告诉用户sql执行的情况。所以现在所有的loading条都是模拟的，这样做感觉没什么意义。除非像上传图片那种流传输可以做精确的百分比加载提示。\n\n\n### 数据库以及数据处理\n数据库直接用最通用的mysql，npm有个包能够直接引用很方便。数据处理上写了个简单的node，先将md文件转成html形式的字符串，然后转成合适的sql输出为sql文件即可。\n\n\n### 云服务器部署以及nginx配置\n服务器用了Amazon aws的Lightsail，最简单。一开始的配置上选了node.js服务器，注意需要将上面的nginx配置删掉/停止然后换成自己的。目前我的nginx配置如下：\n\n    events {\n        worker_connections  1024; #并发数\n    }\n    \n    \n    http {\n        server {\n            listen 80; #监听端口\n            # 静态文件\n            location / {\n                try_files $uri $uri/ @router;\n                root  /data/www;\n                index index.html;\n            }\n    \n            location @router {\n                rewrite ^.*$ /index.html last;\n            }\n    \n            location /js/ {\n                root /data/www;\n            }\n    \n            location /css/ {\n                root /data/www;\n                types {\n                    text/css css;\n                }\n            }\n    \n            location /img/ {\n                root /data/www;\n            }\n    \n            #接口路径\n            location /blog/ {\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                proxy_set_header Host $http_host;\n                proxy_set_header X-NginX-Proxy true;\n    \n                proxy_pass http://localhost:8888/blog/;\n    \n                proxy_redirect off;\n            }\n        }\n    }\n\n由于是单页面应用，根目录需要进行router的配置，为了获取用户IP，需要在接口路径中增加proxy_set_header选项。开发流程是先本地跑通，然后build后在本地nginx跑通，最后在服务端跑通。部署流程是先将文件传到github上，然后在服务端clone下来进行手动的部署。后端服务的部署用了pm2。域名是在godaddy上买的。\n\n#### 附录\n- 博客初步构建：https://quip.com/Oyx6AAiIGj4j\n- 服务器部署：https://quip.com/9tjyAPaWGEmY\n- 第一次迭代：https://quip.com/VLOFA5nYG2ur\n- 第二次迭代：https://quip.com/KMldAae1pnUr', '2019-11-17'),('托福回顾', '\n\n### 关于如何准备\n单词上必须通过那本托福核心词汇，通过听写的形式。我的话第一次掌握的不是很好，然后又过了一遍。\n\n阅读除了做完教材上的题目以外，需要进行限时练习。我的具体的策略是花6分钟通读全文并且做好每段内容的笔记，然后做题。这样对于全文能有个大致的把握。做完后对于错题要有一定的原因分析，原因通常有：细节/理解；选项理解；时间没来得及看；文章大意；词汇；推断等。应该尽量避免推断、词汇、文章大意的错误。\n\n听力在准备上需要进行精听。精听策略是在刷TPO的时候挑出自己错最多的那一篇，三到四题的那种，然后进行单次精听。我比较喜欢打字，所以打到了电脑上。听写完成之后将答案拷贝到另外一篇文章上，在屏幕的左右两边进行对比。做完后也要进行错题的原因分析。\n\n口语必须在考试的节奏上进行练习。可以打开一直录音功能，练习完成之后如果有一些特别不好就再尝试一下并且进行记录。写作也需要进行限时练习。写完之后可以和小站上的范文进行比较。像这种输出类的可能一开始比较困难，但是多说多写后就能克服之前的困难了。\n\n\n\n### 关于启德的老师以及tutor\n\n课上需要认真听讲以及记笔记，最好准备四个笔记本不然很容易乱。\n\n阅读和听力老师会梳理所有的题型，然后对于单词会进行细致的归纳，前者通过词根词缀，后者通过单词意群。听力老师还指出了很重要的考点：列举、反面强调、why mention以及作者态度，对应这些考点的也有具体的记笔记的方式。阅读老师很厉害，听他的课能涨很多见识。\n\n口语以及写作老师会教具体的答题结构，都是容易应用并且有效的方法。上写作老师的课很开心很放松。\n\ntutor主要是监督作用，每次打卡都会发到tutor建的一个群里面，然后也进行了单词的听写。tutor小姐姐人也很好，给了我很多鼓励。\n\n\n### 其他\n托福前前后后准备了三个半月时间，最后的全力准备花了差不多一个月，最后运气比较好达到了目标分。回想起来考试需要足够的信心，有信心才更愿意花费在时间在上面。我两次模考的结果都不是很理想，但是我把自己能做的大部分都完成了，最后也取得了自己想要的分数。除此之外，考前也需要好好休息，这样考试的时候也能轻松一点。', '2019-6-17');COMMIT; SET FOREIGN_KEY_CHECKS = 1;